---
name: delegation-guide
description: 에이전트 자동 위임을 위한 결정 트리. coordinator가 참조.
user-invocable: false
---

# 에이전트 위임 가이드

Coordinator가 참조하는 에이전트 자동 위임 결정 트리입니다.

## 1단계: 작업 도메인 식별

| 키워드 | 도메인 | 에이전트/스킬 | 모델 |
|--------|--------|--------------|------|
| "설계", "아키텍처", "구조", "패턴" | 아키텍처 | @oracle | Opus |
| "계획", "로드맵", "전략", "스택 선택" | 전략 | @prometheus | Opus |
| "리뷰", "검토", "평가", "PR" | 코드 리뷰 | @code-reviewer | Sonnet |
| "버그", "에러", "오류", "디버그" | 디버깅 | @debugger | Sonnet |
| "품질", "비판", "개선", "검증" | 품질 검토 | @momus | Sonnet |
| "문서", "사용법", "레퍼런스", "API" | 문서 검색 | @librarian | Haiku |
| "이미지", "PDF", "스크린샷" | 시각 분석 | @multimodal-looker | Sonnet |
| "다이어그램", "시각화" | 다이어그램 | /arch-diagram 등 | - |
| "TDD", "테스트 주도" | TDD | /tdd-cycle | - |
| "브레인스토밍", "아이디어" | 브레인스토밍 | /brainstorm-session | - |
| "계획 문서", "문서화" | 계획 작성 | /write-plan | - |

---

## 2단계: 복잡도 평가

### 단순 (Coordinator 직접 처리)
- 1-3개 파일 수정
- 명확한 요구사항
- 5분 이내 완료 예상
- 특별한 전문성 불필요

**예시**:
- "이 함수에 주석 추가"
- "변수명을 camelCase로 변경"
- "README에 설치 방법 추가"

**조치**: Sonnet으로 즉시 처리

---

### 중간 (해당 도메인 에이전트 위임)
- 4-10개 파일 수정
- 일부 요구사항 불명확
- 30분 이내 완료 예상
- 특정 도메인 전문성 필요

**예시**:
- "이 코드 리뷰해줘" → @code-reviewer
- "React Query 사용법 알려줘" → @librarian
- "TypeError 원인 찾아줘" → @debugger

**조치**: 해당 전문 에이전트 위임

---

### 복잡 (Opus 에이전트 또는 다중 에이전트)
- 10+ 파일 수정
- 여러 도메인 전문성 필요
- 1시간 이상 예상
- 아키텍처/전략적 결정 필요

**예시**:
- "마이크로서비스 아키텍처 설계" → @oracle
- "사용자 인증 시스템 구현 계획" → @prometheus
- "전체 시스템 리팩토링" → 다중 에이전트

**조치**: Opus 에이전트 또는 다중 에이전트 오케스트레이션

---

## 3단계: 모델 비용 최적화

### Opus 사용 (고비용, 고품질)
**조건**:
- 전략적 결정 필요
- 아키텍처 설계
- 복잡한 기술 트레이드오프
- 깊은 분석 필요

**에이전트**:
- @oracle: 아키텍처, 설계 패턴, 성능 분석
- @prometheus: 프로젝트 계획, 기술 스택 선택

---

### Sonnet 사용 (중간 비용, 균형)
**조건**:
- 대부분의 코드 작업
- 코드 리뷰
- 복잡한 디버깅
- 품질 검증

**에이전트**:
- coordinator: 단순 작업 직접 처리
- @code-reviewer: 코드 리뷰
- @debugger: 버그 수정
- @momus: 품질 검토
- @multimodal-looker: 이미지/PDF 분석

---

### Haiku 사용 (저비용, 빠름)
**조건**:
- 문서 검색
- API 레퍼런스 조회
- 간단한 질문 답변

**에이전트**:
- @librarian: 문서 검색 전담

**비용 절감**: Sonnet 대비 80% 저렴

---

## 4단계: 다중 에이전트 시퀀스

### 시나리오 1: 새 기능 개발 (대규모)
```
1. @prometheus → 전체 계획 수립
2. @oracle → 아키텍처 설계
3. coordinator → 코드 구현
4. @code-reviewer → 코드 리뷰
5. @momus → 최종 품질 검증
```

### 시나리오 2: 버그 수정 (중간)
```
1. @debugger → 버그 원인 분석 및 수정
2. @code-reviewer → 수정 사항 리뷰
3. coordinator → 테스트 작성 및 커밋
```

### 시나리오 3: 아키텍처 개선 (대규모)
```
1. @oracle → 현재 구조 분석 및 개선안
2. @prometheus → 마이그레이션 계획
3. @momus → 계획 검증
4. coordinator → 단계별 구현
5. @code-reviewer → 각 단계 리뷰
```

### 시나리오 4: 문서 작성 (단순)
```
1. @librarian → 관련 문서 검색
2. coordinator → 문서 작성
```

---

## 비용 최적화 전략

### 직접 처리 vs 위임 비교

```python
# 의사결정 공식
direct_cost = sonnet_tokens * sonnet_price
delegation_cost = (
    conversation_overhead +  # 대화 오버헤드
    target_agent_tokens * target_agent_price
)

# 50% 마진으로 판단
if direct_cost < delegation_cost * 1.5:
    return "직접 처리"
else:
    return "에이전트 위임"
```

### 예시 계산

#### 예시 1: 단순 주석 추가
```
직접 처리 (Sonnet): 500 토큰 × $3/1M = $0.0015
위임 (@code-reviewer): (500 오버헤드 + 600 작업) × $3/1M = $0.0033

→ 직접 처리가 2배 저렴!
```

#### 예시 2: 문서 검색
```
직접 처리 (Sonnet): 2000 토큰 × $3/1M = $0.006
위임 (@librarian, Haiku): (500 오버헤드 + 400 작업) × $0.25/1M = $0.000225

→ 위임이 26배 저렴!
```

#### 예시 3: 아키텍처 설계
```
직접 처리 (Sonnet): 8000 토큰 × $3/1M = $0.024 (품질 부족 가능)
위임 (@oracle, Opus): (500 오버헤드 + 10000 작업) × $15/1M = $0.1575

→ 비용은 높지만 품질 향상으로 정당화
```

---

## 키워드 매칭 규칙

### 우선순위 1: 명확한 에이전트 호출
```
사용자: "@oracle 아키텍처 분석해줘"
→ oracle 에이전트 직접 호출
```

### 우선순위 2: 명시적 키워드
```
사용자: "이 코드 리뷰해줘"
→ "리뷰" 키워드 감지 → @code-reviewer
```

### 우선순위 3: 문맥 파악
```
사용자: "TypeError: Cannot read property 'name' of undefined"
→ 에러 메시지 감지 → @debugger
```

### 우선순위 4: 복잡도 판단
```
사용자: "사용자 인증 시스템 구현해줘"
→ 복잡도 높음 → @prometheus (계획) → coordinator (구현)
```

---

## 응답 템플릿

### 직접 처리
```markdown
## 🔍 분석
- 작업 유형: 구현
- 복잡도: 단순
- 최적 전략: 직접 처리
- 이유: 단순 작업으로 즉시 처리 가능

## 🎯 실행
(즉시 작업 수행)
```

### 에이전트 위임
```markdown
## 🔍 분석
- 작업 유형: [...]
- 복잡도: [중간/복잡]
- 최적 전략: @[에이전트] 위임
- 이유: [전문성/비용 효율성]

## 🎯 실행
@[에이전트]에게 요청합니다.

"[구체적 요청 내용]"
```

### 다중 에이전트
```markdown
## 🔍 분석
- 작업 유형: [...]
- 복잡도: 복잡
- 최적 전략: 다중 에이전트 오케스트레이션
- 이유: [여러 도메인 전문성 필요]

## 🎯 실행 계획

**Phase 1**: @[에이전트1] - [목표]
**Phase 2**: @[에이전트2] - [목표]
**Phase 3**: coordinator - [목표]

1단계부터 시작할까요?
```

---

## 예외 처리

### 불명확한 요청
```
사용자: "이거 고쳐줘"
→ AskUserQuestion 도구로 명확화 요청
```

### 범위 밖 요청
```
사용자: "새로운 사업 아이템 제안해줘"
→ 기술 범위 밖임을 설명, 가능한 대안 제시
```

### 과도한 작업량
```
사용자: "전체 시스템을 3일 안에 재작성해줘"
→ 현실적 타임라인 제안, 단계별 접근 권장
```

---

## 요약

에이전트 위임은:
- ✅ 4단계 결정 트리 (도메인 → 복잡도 → 비용 → 시퀀스)
- ✅ 단순 작업은 직접 처리 (오버헤드 제거)
- ✅ 검색은 Haiku (@librarian)로 비용 절감
- ✅ 전략/설계만 Opus 사용
- ✅ 복잡한 작업은 다중 에이전트 오케스트레이션

**핵심**: 최소 비용으로 최대 품질!
